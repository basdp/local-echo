{"version":3,"sources":["webpack://LocalEchoController/webpack/bootstrap","webpack://LocalEchoController/./node_modules/js-tokens/index.js","webpack://LocalEchoController/./lib/HistoryController.js","webpack://LocalEchoController/./lib/Utils.js","webpack://LocalEchoController/./lib/LocalEchoController.js","webpack://LocalEchoController/./index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","IdentifierName","JSXIdentifier","JSXPunctuator","JSXString","JSXText","KeywordsWithExpressionAfter","KeywordsWithNoLineTerminatorAfter","LineTerminatorSequence","MultiLineComment","Newline","NumericLiteral","Punctuator","RegularExpressionLiteral","SingleLineComment","StringLiteral","Template","TokensNotPrecedingObjectLiteral","TokensPrecedingExpression","WhiteSpace","RegExp","source","input","jsx","braces","firstCodePoint","isExpression","lastIndex","lastSignificantToken","length","match","nextLastIndex","nextLastSignificantToken","parenNesting","postfixIncDec","punctuator","stack","tag","test","exec","type","closed","push","nesting","pop","String","fromCodePoint","codePointAt","startsWith","HistoryController","size","this","entries","cursor","entry","trim","idx","Math","max","min","parse","jsString","Array","from","jsTokens","token","wordBoundaries","leftSide","words","rx","index","closestLeftBoundary","offset","found","reverse","find","x","offsetToColRow","maxCols","row","col","charAt","countLines","hasTailingWhitespace","getLastToken","LocalEchoController","term","options","_handleTermData","handleTermData","_handleTermResize","handleTermResize","history","historySize","maxAutocompleteEntries","_autocompleteHandlers","_active","_input","_cursor","_activePrompt","_activeCharPrompt","_termSize","cols","rows","_disposables","loadAddon","attach","detach","off","forEach","dispose","on","onData","onResize","fn","args","findIndex","e","splice","prompt","continuationPrompt","Promise","resolve","reject","write","reason","message","print","normInput","replace","items","padding","println","itemWidth","reduce","width","item","wideCols","floor","wideRows","ceil","rowStr","repeat","applyPrompts","substr","currentPrompt","allRows","applyPromptOffset","moveRows","newInput","clearInput","newPrompt","newCursor","newLines","moveUpRows","callback","setCursor","resume","setInput","ret","then","inputWithPrompt","prevCol","prevRow","newCol","newRow","dir","num","backspace","data","charCodeAt","normData","handleData","ofs","ord","getPrevious","getNext","handleCursorMove","handleCursorErase","split","endsWith","isIncompleteInput","handleReadComplete","handleCursorInsert","inputFragment","candidates","callbacks","tokens","concat","console","error","collectAutocompleteCandidates","sort","lastToken","sameFragment","getSharedFragment","fragment","oldFragment","slice","printAndRestartPrompt","printWide","readChar","yn","rewind"],"mappings":"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","file":"local-echo.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020 Simon Lydell\n// License: MIT.\nvar IdentifierName, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace, jsTokens;\nRegularExpressionLiteral = /\\/(?![*\\/])(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)*(\\/[$_\\u200C\\u200D\\p{ID_Continue}]*|\\\\)?/yu;\nPunctuator = /--|\\+\\+|&&|\\|\\||=>|\\.{3}|\\??\\.(?!\\d)|\\?{2}|(?:[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]/y;\nIdentifierName = /(?=[$_\\p{ID_Start}\\\\])(?:[$_\\u200C\\u200D\\p{ID_Continue}]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+/yu;\nStringLiteral = /(['\"])(?:(?!\\1)[^\\\\\\n\\r]|\\\\(?:\\r\\n|[^]))*(\\1)?/y;\nNumericLiteral = /(?:0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+)n?|0n|[1-9]\\d*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9]\\d*)(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?|0[0-7]+/y;\nTemplate = /[`}](?:[^`\\\\$]|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?/y;\nWhiteSpace = /[\\t\\v\\f\\ufeff\\p{Zs}]+/yu;\nLineTerminatorSequence = /\\r?\\n|[\\r\\u2028\\u2029]/y;\nMultiLineComment = /\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?/y;\nSingleLineComment = /\\/\\/.*/y;\nJSXPunctuator = /[<>.:={}]|\\/(?![\\/*])/y;\nJSXIdentifier = /[$_\\p{ID_Start}][$_\\u200C\\u200D\\p{ID_Continue}-]*/yu;\nJSXString = /(['\"])(?:(?!\\1)[^])*(\\1)?/y;\nJSXText = /[^<>{}]+/y;\nTokensPrecedingExpression = /^(?:[\\/+-]|\\.{3}|\\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;\nTokensNotPrecedingObjectLiteral = /^(?:=>|[;\\]){}]|else|\\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;\nKeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;\nKeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;\nNewline = RegExp(LineTerminatorSequence.source);\nmodule.exports = jsTokens = function*(input, {jsx = false} = {}) {\n\tvar braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;\n\t({length} = input);\n\tlastIndex = 0;\n\tlastSignificantToken = \"\";\n\tstack = [\n\t\t{tag: \"JS\"}\n\t];\n\tbraces = [];\n\tparenNesting = 0;\n\tpostfixIncDec = false;\n\twhile (lastIndex < length) {\n\t\tmode = stack[stack.length - 1];\n\t\tswitch (mode.tag) {\n\t\t\tcase \"JS\":\n\t\t\tcase \"JSNonExpressionParen\":\n\t\t\tcase \"InterpolationInTemplate\":\n\t\t\tcase \"InterpolationInJSX\":\n\t\t\t\tif (input[lastIndex] === \"/\" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {\n\t\t\t\t\tRegularExpressionLiteral.lastIndex = lastIndex;\n\t\t\t\t\tif (match = RegularExpressionLiteral.exec(input)) {\n\t\t\t\t\t\tlastIndex = RegularExpressionLiteral.lastIndex;\n\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\ttype: \"RegularExpressionLiteral\",\n\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\tclosed: match[1] !== void 0 && match[1] !== \"\\\\\"\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPunctuator.lastIndex = lastIndex;\n\t\t\t\tif (match = Punctuator.exec(input)) {\n\t\t\t\t\tpunctuator = match[0];\n\t\t\t\t\tnextLastIndex = Punctuator.lastIndex;\n\t\t\t\t\tnextLastSignificantToken = punctuator;\n\t\t\t\t\tswitch (punctuator) {\n\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\tif (lastSignificantToken === \"?NonExpressionParenKeyword\") {\n\t\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\t\ttag: \"JSNonExpressionParen\",\n\t\t\t\t\t\t\t\t\tnesting: parenNesting\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparenNesting++;\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\tparenNesting--;\n\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\tif (mode.tag === \"JSNonExpressionParen\" && parenNesting === mode.nesting) {\n\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\tnextLastSignificantToken = \"?NonExpressionParenEnd\";\n\t\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"{\":\n\t\t\t\t\t\t\tPunctuator.lastIndex = 0;\n\t\t\t\t\t\t\tisExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));\n\t\t\t\t\t\t\tbraces.push(isExpression);\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"}\":\n\t\t\t\t\t\t\tswitch (mode.tag) {\n\t\t\t\t\t\t\t\tcase \"InterpolationInTemplate\":\n\t\t\t\t\t\t\t\t\tif (braces.length === mode.nesting) {\n\t\t\t\t\t\t\t\t\t\tTemplate.lastIndex = lastIndex;\n\t\t\t\t\t\t\t\t\t\tmatch = Template.exec(input);\n\t\t\t\t\t\t\t\t\t\tlastIndex = Template.lastIndex;\n\t\t\t\t\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\t\t\t\t\tif (match[1] === \"${\") {\n\t\t\t\t\t\t\t\t\t\t\tlastSignificantToken = \"?InterpolationInTemplate\";\n\t\t\t\t\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"TemplateMiddle\",\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"TemplateTail\",\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\t\t\t\t\t\tclosed: match[1] === \"`\"\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"InterpolationInJSX\":\n\t\t\t\t\t\t\t\t\tif (braces.length === mode.nesting) {\n\t\t\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\t\t\tlastIndex += 1;\n\t\t\t\t\t\t\t\t\t\tlastSignificantToken = \"}\";\n\t\t\t\t\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\t\t\t\t\tvalue: \"}\"\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpostfixIncDec = braces.pop();\n\t\t\t\t\t\t\tnextLastSignificantToken = postfixIncDec ? \"?ExpressionBraceEnd\" : \"}\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"]\":\n\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"++\":\n\t\t\t\t\t\tcase \"--\":\n\t\t\t\t\t\t\tnextLastSignificantToken = postfixIncDec ? \"?PostfixIncDec\" : \"?UnaryIncDec\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\t\tif (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {\n\t\t\t\t\t\t\t\tstack.push({tag: \"JSXTag\"});\n\t\t\t\t\t\t\t\tlastIndex += 1;\n\t\t\t\t\t\t\t\tlastSignificantToken = \"<\";\n\t\t\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\t\t\tvalue: punctuator\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t}\n\t\t\t\t\tlastIndex = nextLastIndex;\n\t\t\t\t\tlastSignificantToken = nextLastSignificantToken;\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"Punctuator\",\n\t\t\t\t\t\tvalue: punctuator\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tIdentifierName.lastIndex = lastIndex;\n\t\t\t\tif (match = IdentifierName.exec(input)) {\n\t\t\t\t\tlastIndex = IdentifierName.lastIndex;\n\t\t\t\t\tnextLastSignificantToken = match[0];\n\t\t\t\t\tswitch (match[0]) {\n\t\t\t\t\t\tcase \"for\":\n\t\t\t\t\t\tcase \"if\":\n\t\t\t\t\t\tcase \"while\":\n\t\t\t\t\t\tcase \"with\":\n\t\t\t\t\t\t\tif (lastSignificantToken !== \".\" && lastSignificantToken !== \"?.\") {\n\t\t\t\t\t\t\t\tnextLastSignificantToken = \"?NonExpressionParenKeyword\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlastSignificantToken = nextLastSignificantToken;\n\t\t\t\t\tpostfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"IdentifierName\",\n\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tStringLiteral.lastIndex = lastIndex;\n\t\t\t\tif (match = StringLiteral.exec(input)) {\n\t\t\t\t\tlastIndex = StringLiteral.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"StringLiteral\",\n\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\tclosed: match[2] !== void 0\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNumericLiteral.lastIndex = lastIndex;\n\t\t\t\tif (match = NumericLiteral.exec(input)) {\n\t\t\t\t\tlastIndex = NumericLiteral.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"NumericLiteral\",\n\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tTemplate.lastIndex = lastIndex;\n\t\t\t\tif (match = Template.exec(input)) {\n\t\t\t\t\tlastIndex = Template.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tif (match[1] === \"${\") {\n\t\t\t\t\t\tlastSignificantToken = \"?InterpolationInTemplate\";\n\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\ttag: \"InterpolationInTemplate\",\n\t\t\t\t\t\t\tnesting: braces.length\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\ttype: \"TemplateHead\",\n\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\ttype: \"NoSubstitutionTemplate\",\n\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\tclosed: match[1] === \"`\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"JSXTag\":\n\t\t\tcase \"JSXTagEnd\":\n\t\t\t\tJSXPunctuator.lastIndex = lastIndex;\n\t\t\t\tif (match = JSXPunctuator.exec(input)) {\n\t\t\t\t\tlastIndex = JSXPunctuator.lastIndex;\n\t\t\t\t\tnextLastSignificantToken = match[0];\n\t\t\t\t\tswitch (match[0]) {\n\t\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\t\tstack.push({tag: \"JSXTag\"});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \">\":\n\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\tif (lastSignificantToken === \"/\" || mode.tag === \"JSXTagEnd\") {\n\t\t\t\t\t\t\t\tnextLastSignificantToken = \"?JSX\";\n\t\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstack.push({tag: \"JSXChildren\"});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"{\":\n\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\ttag: \"InterpolationInJSX\",\n\t\t\t\t\t\t\t\tnesting: braces.length\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tnextLastSignificantToken = \"?InterpolationInJSX\";\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\t\tif (lastSignificantToken === \"<\") {\n\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\tif (stack[stack.length - 1].tag === \"JSXChildren\") {\n\t\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstack.push({tag: \"JSXTagEnd\"});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlastSignificantToken = nextLastSignificantToken;\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tJSXIdentifier.lastIndex = lastIndex;\n\t\t\t\tif (match = JSXIdentifier.exec(input)) {\n\t\t\t\t\tlastIndex = JSXIdentifier.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"JSXIdentifier\",\n\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tJSXString.lastIndex = lastIndex;\n\t\t\t\tif (match = JSXString.exec(input)) {\n\t\t\t\t\tlastIndex = JSXString.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"JSXString\",\n\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\tclosed: match[2] !== void 0\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"JSXChildren\":\n\t\t\t\tJSXText.lastIndex = lastIndex;\n\t\t\t\tif (match = JSXText.exec(input)) {\n\t\t\t\t\tlastIndex = JSXText.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"JSXText\",\n\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (input[lastIndex]) {\n\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\tstack.push({tag: \"JSXTag\"});\n\t\t\t\t\t\tlastIndex++;\n\t\t\t\t\t\tlastSignificantToken = \"<\";\n\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\tvalue: \"<\"\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase \"{\":\n\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\ttag: \"InterpolationInJSX\",\n\t\t\t\t\t\t\tnesting: braces.length\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlastIndex++;\n\t\t\t\t\t\tlastSignificantToken = \"?InterpolationInJSX\";\n\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\tvalue: \"{\"\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t}\n\t\tWhiteSpace.lastIndex = lastIndex;\n\t\tif (match = WhiteSpace.exec(input)) {\n\t\t\tlastIndex = WhiteSpace.lastIndex;\n\t\t\tyield ({\n\t\t\t\ttype: \"WhiteSpace\",\n\t\t\t\tvalue: match[0]\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tLineTerminatorSequence.lastIndex = lastIndex;\n\t\tif (match = LineTerminatorSequence.exec(input)) {\n\t\t\tlastIndex = LineTerminatorSequence.lastIndex;\n\t\t\tpostfixIncDec = false;\n\t\t\tif (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {\n\t\t\t\tlastSignificantToken = \"?NoLineTerminatorHere\";\n\t\t\t}\n\t\t\tyield ({\n\t\t\t\ttype: \"LineTerminatorSequence\",\n\t\t\t\tvalue: match[0]\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tMultiLineComment.lastIndex = lastIndex;\n\t\tif (match = MultiLineComment.exec(input)) {\n\t\t\tlastIndex = MultiLineComment.lastIndex;\n\t\t\tif (Newline.test(match[0])) {\n\t\t\t\tpostfixIncDec = false;\n\t\t\t\tif (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {\n\t\t\t\t\tlastSignificantToken = \"?NoLineTerminatorHere\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tyield ({\n\t\t\t\ttype: \"MultiLineComment\",\n\t\t\t\tvalue: match[0],\n\t\t\t\tclosed: match[1] !== void 0\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tSingleLineComment.lastIndex = lastIndex;\n\t\tif (match = SingleLineComment.exec(input)) {\n\t\t\tlastIndex = SingleLineComment.lastIndex;\n\t\t\tpostfixIncDec = false;\n\t\t\tyield ({\n\t\t\t\ttype: \"SingleLineComment\",\n\t\t\t\tvalue: match[0]\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tfirstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));\n\t\tlastIndex += firstCodePoint.length;\n\t\tlastSignificantToken = firstCodePoint;\n\t\tpostfixIncDec = false;\n\t\tyield ({\n\t\t\ttype: mode.tag.startsWith(\"JSX\") ? \"JSXInvalid\" : \"Invalid\",\n\t\t\tvalue: firstCodePoint\n\t\t});\n\t}\n\treturn void 0;\n};\n","/**\r\n * The history controller provides an ring-buffer\r\n */\r\nexport class HistoryController {\r\n  constructor(size) {\r\n    this.size = size;\r\n    this.entries = [];\r\n    this.cursor = 0;\r\n  }\r\n\r\n  /**\r\n   * Push an entry and maintain ring buffer size\r\n   */\r\n  push(entry) {\r\n    // Skip empty entries\r\n    if (entry.trim() === \"\") return;\r\n    // Skip duplicate entries\r\n    const lastEntry = this.entries[this.entries.length - 1];\r\n    if (entry == lastEntry) return;\r\n    // Keep track of entries\r\n    this.entries.push(entry);\r\n    if (this.entries.length > this.size) {\r\n      this.entries.pop(0);\r\n    }\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Rewind history cursor on the last entry\r\n   */\r\n  rewind() {\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Returns the previous entry\r\n   */\r\n  getPrevious() {\r\n    const idx = Math.max(0, this.cursor - 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n\r\n  /**\r\n   * Returns the next entry\r\n   */\r\n  getNext() {\r\n    const idx = Math.min(this.entries.length, this.cursor + 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n}\r\n","//import { parse } from \"shell-quote\";\r\nimport jsTokens from \"js-tokens\";\r\n\r\nfunction parse(jsString) {\r\n  return Array.from(jsTokens(jsString), (token) => token.value);\r\n}\r\n\r\n/**\r\n * Detects all the word boundaries on the given input\r\n */\r\nexport function wordBoundaries(input, leftSide = true) {\r\n  let match;\r\n  const words = [];\r\n  const rx = /\\w+/g;\r\n\r\n  while ((match = rx.exec(input))) {\r\n    if (leftSide) {\r\n      words.push(match.index);\r\n    } else {\r\n      words.push(match.index + match[0].length);\r\n    }\r\n  }\r\n\r\n  return words;\r\n}\r\n\r\n/**\r\n * The closest left (or right) word boundary of the given input at the\r\n * given offset.\r\n */\r\nexport function closestLeftBoundary(input, offset) {\r\n  const found = wordBoundaries(input, true)\r\n    .reverse()\r\n    .find(x => x < offset);\r\n  return found == null ? 0 : found;\r\n}\r\nexport function closestRightBoundary(input, offset) {\r\n  const found = wordBoundaries(input, false).find(x => x > offset);\r\n  return found == null ? input.length : found;\r\n}\r\n\r\n/**\r\n * Convert offset at the given input to col/row location\r\n *\r\n * This function is not optimized and practically emulates via brute-force\r\n * the navigation on the terminal, wrapping when they reach the column width.\r\n */\r\nexport function offsetToColRow(input, offset, maxCols) {\r\n  let row = 0,\r\n    col = 0;\r\n\r\n  for (let i = 0; i < offset; ++i) {\r\n    const chr = input.charAt(i);\r\n    if (chr == \"\\n\") {\r\n      col = 0;\r\n      row += 1;\r\n    } else {\r\n      col += 1;\r\n      if (col > maxCols) {\r\n        col = 0;\r\n        row += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { row, col };\r\n}\r\n\r\n/**\r\n * Counts the lines in the given input\r\n */\r\nexport function countLines(input, maxCols) {\r\n  return offsetToColRow(input, input.length, maxCols).row + 1;\r\n}\r\n\r\n/**\r\n * Checks if there is an incomplete input\r\n *\r\n * An incomplete input is considered:\r\n * - An input that contains unterminated single quotes\r\n * - An input that contains unterminated double quotes\r\n * - An input that ends with \"\\\"\r\n * - An input that has an incomplete boolean shell expression (&& and ||)\r\n * - An incomplete pipe expression (|)\r\n */\r\nexport function isIncompleteInput(input) {\r\n  // Empty input is not incomplete\r\n  if (input.trim() == \"\") {\r\n    return false;\r\n  }\r\n\r\n  // Check for dangling single-quote strings\r\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling double-quote strings\r\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling boolean or pipe operations\r\n  if (\r\n    input\r\n      .split(/(\\|\\||\\||&&)/g)\r\n      .pop()\r\n      .trim() == \"\"\r\n  ) {\r\n    return true;\r\n  }\r\n  // Check for tailing slash\r\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns true if the expression ends on a tailing whitespace\r\n */\r\nexport function hasTailingWhitespace(input) {\r\n  return input.match(/[^\\\\][ \\t]$/m) != null;\r\n}\r\n\r\n/**\r\n * Returns the last expression in the given input\r\n */\r\nexport function getLastToken(input) {\r\n  // Empty expressions\r\n  if (input.trim() === \"\") return \"\";\r\n  if (hasTailingWhitespace(input)) return \"\";\r\n\r\n  // Last token\r\n  const tokens = parse(input);\r\n  return tokens.pop() || \"\";\r\n}\r\n\r\n/**\r\n * Returns the auto-complete candidates for the given input\r\n */\r\nexport function collectAutocompleteCandidates(callbacks, input) {\r\n  const tokens = parse(input);\r\n  let index = tokens.length - 1;\r\n  let expr = tokens[index] || \"\";\r\n\r\n  // Empty expressions\r\n  if (input.trim() === \"\") {\r\n    index = 0;\r\n    expr = \"\";\r\n  } else if (hasTailingWhitespace(input)) {\r\n    // Expressions with danging space\r\n    index += 1;\r\n    expr = \"\";\r\n  }\r\n\r\n  // Collect all auto-complete candidates from the callbacks\r\n  const all = callbacks.reduce((candidates, { fn, args }) => {\r\n    try {\r\n      return candidates.concat(fn(index, tokens, ...args));\r\n    } catch (e) {\r\n      console.error(\"Auto-complete error:\", e);\r\n      return candidates;\r\n    }\r\n  }, []);\r\n\r\n  // Filter only the ones starting with the expression\r\n  return all;//.filter(txt => txt.startsWith(expr));\r\n}\r\n\r\n\r\nexport function getSharedFragment(fragment, candidates) {\r\n\r\n  // end loop when fragment length = first candidate length\r\n  if (fragment.length >= candidates[0].length) return fragment;\r\n  \r\n  // save old fragemnt\r\n  const oldFragment = fragment;\r\n  \r\n  // get new fragment\r\n  fragment += candidates[0].slice(fragment.length, fragment.length+1);\r\n\r\n  for (let i=0; i<candidates.length; i++ ) {\r\n\r\n    // return null when there's a wrong candidate\r\n    if (!candidates[i].startsWith(oldFragment)) return null;\r\n\r\n    if (!candidates[i].startsWith(fragment)) {\r\n      return oldFragment;\r\n    }\r\n  }\r\n\r\n  return getSharedFragment(fragment, candidates);\r\n}\r\n","import { HistoryController } from \"./HistoryController\";\r\nimport {\r\n  closestLeftBoundary,\r\n  closestRightBoundary,\r\n  collectAutocompleteCandidates,\r\n  countLines,\r\n  getLastToken,\r\n  hasTailingWhitespace,\r\n  isIncompleteInput,\r\n  offsetToColRow,\r\n  getSharedFragment\r\n} from \"./Utils\";\r\n\r\n/**\r\n * A local terminal controller is responsible for displaying messages\r\n * and handling local echo for the terminal.\r\n *\r\n * Local echo supports most of bash-like input primitives. Namely:\r\n * - Arrow navigation on the input\r\n * - Alt-arrow for word-boundary navigation\r\n * - Alt-backspace for word-boundary deletion\r\n * - Multi-line input for incomplete commands\r\n * - Auto-complete hooks\r\n */\r\nexport default class LocalEchoController {\r\n  constructor(term = null, options = {}) {\r\n    this.term = term;\r\n    this._handleTermData = this.handleTermData.bind(this);\r\n    this._handleTermResize = this.handleTermResize.bind(this)\r\n    \r\n    this.history = new HistoryController(options.historySize || 10);\r\n    this.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;\r\n\r\n    this._autocompleteHandlers = [];\r\n    this._active = false;\r\n    this._input = \"\";\r\n    this._cursor = 0;\r\n    this._activePrompt = null;\r\n    this._activeCharPrompt = null;\r\n    this._termSize = {\r\n      cols: 0,\r\n      rows: 0,\r\n    };\r\n\r\n    this._disposables = [];\r\n    \r\n    if (term) {\r\n      if (term.loadAddon) term.loadAddon(this);\r\n      else this.attach();\r\n    }\r\n  }\r\n\r\n  // xterm.js new plugin API:\r\n  activate(term) {\r\n    this.term = term;\r\n    this.attach();\r\n  }\r\n  dispose() {\r\n    this.detach();\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // User-Facing API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  \r\n  /**\r\n   *  Detach the controller from the terminal\r\n   */\r\n  detach() {\r\n    if (this.term.off) {\r\n      this.term.off(\"data\", this._handleTermData);\r\n      this.term.off(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.forEach(d => d.dispose());\r\n      this._disposables = [];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Attach controller to the terminal, handling events\r\n   */\r\n  attach() {\r\n    if (this.term.on) {\r\n      this.term.on(\"data\", this._handleTermData);\r\n      this.term.on(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.push(this.term.onData(this._handleTermData));\r\n      this._disposables.push(this.term.onResize(this._handleTermResize));\r\n    }\r\n    this._termSize = {\r\n      cols: this.term.cols,\r\n      rows: this.term.rows,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Register a handler that will be called to satisfy auto-completion\r\n   */\r\n  addAutocompleteHandler(fn, ...args) {\r\n    this._autocompleteHandlers.push({\r\n      fn,\r\n      args\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove a previously registered auto-complete handler\r\n   */\r\n  removeAutocompleteHandler(fn) {\r\n    const idx = this._autocompleteHandlers.findIndex(e => e.fn === fn);\r\n    if (idx === -1) return;\r\n\r\n    this._autocompleteHandlers.splice(idx, 1);\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will resolve when the user has completed\r\n   * typing a single line\r\n   */\r\n  read(prompt, continuationPrompt = \"> \") {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activePrompt = {\r\n        prompt,\r\n        continuationPrompt,\r\n        resolve,\r\n        reject\r\n      };\r\n\r\n      this._input = \"\";\r\n      this._cursor = 0;\r\n      this._active = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will be resolved when the user types a single\r\n   * character.\r\n   *\r\n   * This can be active in addition to `.read()` and will be resolved in\r\n   * priority before it.\r\n   */\r\n  readChar(prompt) {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activeCharPrompt = {\r\n        prompt,\r\n        resolve,\r\n        reject\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Abort a pending read operation\r\n   */\r\n  abortRead(reason = \"aborted\") {\r\n    if (this._activePrompt != null || this._activeCharPrompt != null) {\r\n      this.term.write(\"\\r\\n\");\r\n    }\r\n    if (this._activePrompt != null) {\r\n      this._activePrompt.reject(reason);\r\n      this._activePrompt = null;\r\n    }\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.reject(reason);\r\n      this._activeCharPrompt = null;\r\n    }\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Prints a message and changes line\r\n   */\r\n  println(message) {\r\n    this.print(message + \"\\n\");\r\n  }\r\n\r\n  /**\r\n   * Prints a message and properly handles new-lines\r\n   */\r\n  print(message) {\r\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\r\n    this.term.write(normInput.replace(/\\n/g, \"\\r\\n\"));\r\n  }\r\n\r\n  /**\r\n   * Prints a list of items using a wide-format\r\n   */\r\n  printWide(items, padding = 2) {\r\n    if (items.length == 0) return println(\"\");\r\n\r\n    // Compute item sizes and matrix row/cols\r\n    const itemWidth =\r\n      items.reduce((width, item) => Math.max(width, item.length), 0) + padding;\r\n    const wideCols = Math.floor(this._termSize.cols / itemWidth);\r\n    const wideRows = Math.ceil(items.length / wideCols);\r\n\r\n    // Print matrix\r\n    let i = 0;\r\n    for (let row = 0; row < wideRows; ++row) {\r\n      let rowStr = \"\";\r\n\r\n      // Prepare columns\r\n      for (let col = 0; col < wideCols; ++col) {\r\n        if (i < items.length) {\r\n          let item = items[i++];\r\n          item += \" \".repeat(itemWidth - item.length);\r\n          rowStr += item;\r\n        }\r\n      }\r\n      this.println(rowStr);\r\n    }\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // Internal API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n   * Apply prompts to the given input\r\n   */\r\n  applyPrompts(input) {\r\n    const prompt = (this._activePrompt || {}).prompt || \"\";\r\n    const continuationPrompt =\r\n      (this._activePrompt || {}).continuationPrompt || \"\";\r\n\r\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\r\n  }\r\n\r\n  /**\r\n   * Advances the `offset` as required in order to accompany the prompt\r\n   * additions to the input.\r\n   */\r\n  applyPromptOffset(input, offset) {\r\n    const newInput = this.applyPrompts(input.substr(0, offset));\r\n    return newInput.length;\r\n  }\r\n\r\n  /**\r\n   * Clears the current prompt\r\n   *\r\n   * This function will erase all the lines that display the current prompt\r\n   * and move the cursor in the beginning of the first line of the prompt.\r\n   */\r\n  clearInput() {\r\n    const currentPrompt = this.applyPrompts(this._input);\r\n\r\n    // Get the overall number of lines to clear\r\n    const allRows = countLines(currentPrompt, this._termSize.cols);\r\n\r\n    // Get the line we are currently in\r\n    const promptCursor = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col, row } = offsetToColRow(\r\n      currentPrompt,\r\n      promptCursor,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // First move on the last line\r\n    const moveRows = allRows - row - 1;\r\n    for (var i = 0; i < moveRows; ++i) this.term.write(\"\\x1B[E\");\r\n\r\n    // Clear current input line(s)\r\n    this.term.write(\"\\r\\x1B[K\");\r\n    for (var i = 1; i < allRows; ++i) this.term.write(\"\\x1B[F\\x1B[K\");\r\n  }\r\n\r\n  /**\r\n   * Replace input with the new input given\r\n   *\r\n   * This function clears all the lines that the current input occupies and\r\n   * then replaces them with the new input.\r\n   */\r\n  setInput(newInput, clearInput = true) {\r\n    // Clear current input\r\n    if (clearInput) this.clearInput();\r\n\r\n    // Write the new input lines, including the current prompt\r\n    const newPrompt = this.applyPrompts(newInput);\r\n    this.print(newPrompt);\r\n\r\n    // Trim cursor overflow\r\n    if (this._cursor > newInput.length) {\r\n      this._cursor = newInput.length;\r\n    }\r\n\r\n    // Move the cursor to the appropriate row/col\r\n    const newCursor = this.applyPromptOffset(newInput, this._cursor);\r\n    const newLines = countLines(newPrompt, this._termSize.cols);\r\n    const { col, row } = offsetToColRow(\r\n      newPrompt,\r\n      newCursor,\r\n      this._termSize.cols\r\n    );\r\n    const moveUpRows = newLines - row - 1;\r\n\r\n    this.term.write(\"\\r\");\r\n    for (var i = 0; i < moveUpRows; ++i) this.term.write(\"\\x1B[F\");\r\n    for (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\r\n\r\n    // Replace input\r\n    this._input = newInput;\r\n  }\r\n\r\n  /**\r\n   * This function completes the current input, calls the given callback\r\n   * and then re-displays the prompt.\r\n   */\r\n  printAndRestartPrompt(callback) {\r\n    const cursor = this._cursor;\r\n\r\n    // Complete input\r\n    this.setCursor(this._input.length);\r\n    this.term.write(\"\\r\\n\");\r\n\r\n    // Prepare a function that will resume prompt\r\n    const resume = () => {\r\n      this._cursor = cursor;\r\n      this.setInput(this._input);\r\n    };\r\n\r\n    // Call the given callback to echo something, and if there is a promise\r\n    // returned, wait for the resolution before resuming prompt.\r\n    const ret = callback();\r\n    if (ret == null) {\r\n      resume();\r\n    } else {\r\n      ret.then(resume);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the new cursor position, as an offset on the input string\r\n   *\r\n   * This function:\r\n   * - Calculates the previous and current\r\n   */\r\n  setCursor(newCursor) {\r\n    if (newCursor < 0) newCursor = 0;\r\n    if (newCursor > this._input.length) newCursor = this._input.length;\r\n\r\n    // Apply prompt formatting to get the visual status of the display\r\n    const inputWithPrompt = this.applyPrompts(this._input);\r\n    const inputLines = countLines(inputWithPrompt, this._termSize.cols);\r\n\r\n    // Estimate previous cursor position\r\n    const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col: prevCol, row: prevRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      prevPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Estimate next cursor position\r\n    const newPromptOffset = this.applyPromptOffset(this._input, newCursor);\r\n    const { col: newCol, row: newRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      newPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Adjust vertically\r\n    if (newRow > prevRow) {\r\n      for (let i = prevRow; i < newRow; ++i) this.term.write(\"\\x1B[B\");\r\n    } else {\r\n      for (let i = newRow; i < prevRow; ++i) this.term.write(\"\\x1B[A\");\r\n    }\r\n\r\n    // Adjust horizontally\r\n    if (newCol > prevCol) {\r\n      for (let i = prevCol; i < newCol; ++i) this.term.write(\"\\x1B[C\");\r\n    } else {\r\n      for (let i = newCol; i < prevCol; ++i) this.term.write(\"\\x1B[D\");\r\n    }\r\n\r\n    // Set new offset\r\n    this._cursor = newCursor;\r\n  }\r\n\r\n  /**\r\n   * Move cursor at given direction\r\n   */\r\n  handleCursorMove(dir) {\r\n    if (dir > 0) {\r\n      const num = Math.min(dir, this._input.length - this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    } else if (dir < 0) {\r\n      const num = Math.max(dir, -this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Erase a character at cursor location\r\n   */\r\n  handleCursorErase(backspace) {\r\n    const { _cursor, _input } = this;\r\n    if (backspace) {\r\n      if (_cursor <= 0) return;\r\n      const newInput = _input.substr(0, _cursor - 1) + _input.substr(_cursor);\r\n      this.clearInput();\r\n      this._cursor -= 1;\r\n      this.setInput(newInput, false);\r\n    } else {\r\n      const newInput = _input.substr(0, _cursor) + _input.substr(_cursor + 1);\r\n      this.setInput(newInput);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Insert character at cursor location\r\n   */\r\n  handleCursorInsert(data) {\r\n    const { _cursor, _input } = this;\r\n    const newInput = _input.substr(0, _cursor) + data + _input.substr(_cursor);\r\n    this._cursor += data.length;\r\n    this.setInput(newInput);\r\n  }\r\n\r\n  /**\r\n   * Handle input completion\r\n   */\r\n  handleReadComplete() {\r\n    if (this.history) {\r\n      this.history.push(this._input);\r\n    }\r\n    if (this._activePrompt) {\r\n      this._activePrompt.resolve(this._input);\r\n      this._activePrompt = null;\r\n    }\r\n    this.term.write(\"\\r\\n\");\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Handle terminal resize\r\n   *\r\n   * This function clears the prompt using the previous configuration,\r\n   * updates the cached terminal size information and then re-renders the\r\n   * input. This leads (most of the times) into a better formatted input.\r\n   */\r\n  handleTermResize(data) {\r\n    const { rows, cols } = data;\r\n    this.clearInput();\r\n    this._termSize = { cols, rows };\r\n    this.setInput(this._input, false);\r\n  }\r\n\r\n  /**\r\n   * Handle terminal input\r\n   */\r\n  handleTermData(data) {\r\n    if (!this._active) return;\r\n\r\n    // If we have an active character prompt, satisfy it in priority\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.resolve(data);\r\n      this._activeCharPrompt = null;\r\n      this.term.write(\"\\r\\n\");\r\n      return;\r\n    }\r\n\r\n    // If this looks like a pasted input, expand it\r\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\r\n      const normData = data.replace(/[\\r\\n]+/g, \"\\r\");\r\n      Array.from(normData).forEach(c => this.handleData(c));\r\n    } else {\r\n      this.handleData(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a single piece of information from the terminal.\r\n   */\r\n  handleData(data) {\r\n    if (!this._active) return;\r\n    const ord = data.charCodeAt(0);\r\n    let ofs;\r\n\r\n    // Handle ANSI escape sequences\r\n    if (ord == 0x1b) {\r\n      switch (data.substr(1)) {\r\n        case \"[A\": // Up arrow\r\n          if (this.history) {\r\n            let value = this.history.getPrevious();\r\n            if (value) {\r\n              this.setInput(value);\r\n              this.setCursor(value.length);\r\n            }\r\n          }\r\n          break;\r\n\r\n        case \"[B\": // Down arrow\r\n          if (this.history) {\r\n            let value = this.history.getNext();\r\n            if (!value) value = \"\";\r\n            this.setInput(value);\r\n            this.setCursor(value.length);\r\n          }\r\n          break;\r\n\r\n        case \"[D\": // Left Arrow\r\n          this.handleCursorMove(-1);\r\n          break;\r\n\r\n        case \"[C\": // Right Arrow\r\n          this.handleCursorMove(1);\r\n          break;\r\n\r\n        case \"[3~\": // Delete\r\n          this.handleCursorErase(false);\r\n          break;\r\n\r\n        case \"[F\": // End\r\n          this.setCursor(this._input.length);\r\n          break;\r\n\r\n        case \"[H\": // Home\r\n          this.setCursor(0);\r\n          break;\r\n\r\n        case \"b\": // ALT + LEFT\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"f\": // ALT + RIGHT\r\n          ofs = closestRightBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"\\x7F\": // CTRL + BACKSPACE\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) {\r\n            this.setInput(\r\n              this._input.substr(0, ofs) + this._input.substr(this._cursor)\r\n            );\r\n            this.setCursor(ofs);\r\n          }\r\n          break;\r\n      }\r\n\r\n      // Handle special characters\r\n    } else if (ord < 32 || ord === 0x7f) {\r\n      switch (data) {\r\n        case \"\\r\": // ENTER\r\n          if (isIncompleteInput(this._input)) {\r\n            this.handleCursorInsert(\"\\n\");\r\n          } else {\r\n            this.handleReadComplete();\r\n          }\r\n          break;\r\n\r\n        case \"\\x7F\": // BACKSPACE\r\n          this.handleCursorErase(true);\r\n          break;\r\n\r\n        case \"\\t\": // TAB\r\n          if (this._autocompleteHandlers.length > 0) {\r\n            const inputFragment = this._input.substr(0, this._cursor);\r\n            const hasTailingSpace = hasTailingWhitespace(inputFragment);\r\n            const candidates = collectAutocompleteCandidates(\r\n              this._autocompleteHandlers,\r\n              inputFragment\r\n            );\r\n\r\n            // Sort candidates\r\n            candidates.sort();\r\n\r\n            // Depending on the number of candidates, we are handing them in\r\n            // a different way.\r\n            if (candidates.length === 0) {\r\n              // No candidates? Just add a space if there is none already\r\n              if (!hasTailingSpace) {\r\n                //this.handleCursorInsert(\" \");\r\n              }\r\n            } else if (candidates.length === 1) {\r\n              // Just a single candidate? Complete\r\n              let lastToken = getLastToken(inputFragment);\r\n              this.handleCursorInsert(\r\n                candidates[0].substr(lastToken.length)// + \" \"\r\n              );\r\n            } else if (candidates.length <= this.maxAutocompleteEntries) {\r\n\r\n              // search for a shared fragement\r\n              const sameFragment = getSharedFragment(inputFragment, candidates);\r\n              \r\n              // if there's a shared fragement between the candidates\r\n              // print complete the shared fragment\r\n              if (sameFragment) {\r\n                const lastToken = getLastToken(inputFragment);\r\n                this.handleCursorInsert(\r\n                  sameFragment.substr(lastToken.length)\r\n                );\r\n              }\r\n\r\n              // If we are less than maximum auto-complete candidates, print\r\n              // them to the user and re-start prompt\r\n              this.printAndRestartPrompt(() => {\r\n                this.printWide(candidates);\r\n              });\r\n            } else {\r\n              // If we have more than maximum auto-complete candidates, print\r\n              // them only if the user acknowledges a warning\r\n              this.printAndRestartPrompt(() =>\r\n                this.readChar(\r\n                  `Display all ${candidates.length} possibilities? (y or n)`\r\n                ).then(yn => {\r\n                  if (yn == \"y\" || yn == \"Y\") {\r\n                    this.printWide(candidates);\r\n                  }\r\n                })\r\n              );\r\n            }\r\n          } else {\r\n            this.handleCursorInsert(\"    \");\r\n          }\r\n          break;\r\n\r\n        case \"\\x03\": // CTRL+C\r\n          this.setCursor(this._input.length);\r\n          this.term.write(\"^C\\r\\n\" + ((this._activePrompt || {}).prompt || \"\"));\r\n          this._input = \"\";\r\n          this._cursor = 0;\r\n          if (this.history) this.history.rewind();\r\n          break;\r\n      }\r\n\r\n      // Handle visible characters\r\n    } else {\r\n      this.handleCursorInsert(data);\r\n    }\r\n  }\r\n}\r\n","import LocalEchoController from \"./lib/LocalEchoController\";\r\nexport { HistoryController } from './lib/HistoryController';\r\n\r\nexport default LocalEchoController;\r\n"],"sourceRoot":""}