{"version":3,"sources":["webpack://LocalEchoController/webpack/bootstrap","webpack://LocalEchoController/./node_modules/shell-quote/index.js","webpack://LocalEchoController/./lib/HistoryController.js","webpack://LocalEchoController/./lib/Utils.js","webpack://LocalEchoController/./lib/LocalEchoController.js","webpack://LocalEchoController/./index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","quote","xs","map","op","replace","test","String","join","CONTROL","TOKEN","Math","pow","random","toString","parse","env","opts","mapped","chunker","RegExp","match","filter","Boolean","commented","j","BS","escape","esc","out","isGlob","len","length","charAt","parseEnvVar","comment","slice","pattern","varend","varname","Error","substr","indexOf","index","_","pre","undefined","JSON","stringify","getVar","reduce","prev","arg","concat","acc","split","x","HistoryController","size","this","entries","cursor","entry","trim","push","pop","idx","max","min","wordBoundaries","input","leftSide","words","rx","exec","closestLeftBoundary","offset","found","reverse","find","offsetToColRow","maxCols","row","col","countLines","hasTailingWhitespace","getLastToken","LocalEchoController","term","options","_handleTermData","handleTermData","_handleTermResize","handleTermResize","history","historySize","maxAutocompleteEntries","_autocompleteHandlers","_active","_input","_cursor","_activePrompt","_activeCharPrompt","_termSize","cols","rows","_disposables","loadAddon","attach","detach","off","forEach","dispose","on","onData","onResize","fn","args","findIndex","e","splice","prompt","continuationPrompt","Promise","resolve","reject","write","reason","message","print","normInput","items","padding","println","itemWidth","width","item","wideCols","floor","wideRows","ceil","rowStr","repeat","applyPrompts","currentPrompt","allRows","applyPromptOffset","moveRows","newInput","clearInput","newPrompt","newCursor","newLines","moveUpRows","callback","setCursor","resume","setInput","ret","then","inputWithPrompt","prevCol","prevRow","newCol","newRow","dir","num","backspace","data","charCodeAt","normData","Array","from","handleData","ofs","ord","getPrevious","getNext","handleCursorMove","handleCursorErase","endsWith","isIncompleteInput","handleReadComplete","handleCursorInsert","inputFragment","candidates","callbacks","tokens","expr","console","error","txt","startsWith","collectAutocompleteCandidates","sort","lastToken","sameFragment","getSharedFragment","fragment","oldFragment","printAndRestartPrompt","printWide","readChar","yn","rewind"],"mappings":"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","file":"local-echo.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","exports.quote = function (xs) {\n    return xs.map(function (s) {\n        if (s && typeof s === 'object') {\n            return s.op.replace(/(.)/g, '\\\\$1');\n        }\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n        }\n        else if (/[\"'\\s]/.test(s)) {\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n        }\n        else {\n            return String(s).replace(/([A-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n        }\n    }).join(' ');\n};\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n    var mapped = parse(s, env, opts);\n    if (typeof env !== 'function') return mapped;\n    return mapped.reduce(function (acc, s) {\n        if (typeof s === 'object') return acc.concat(s);\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n        if (xs.length === 1) return acc.concat(xs[0]);\n        return acc.concat(xs.filter(Boolean).map(function (x) {\n            if (RegExp('^' + TOKEN).test(x)) {\n                return JSON.parse(x.split(TOKEN)[1]);\n            }\n            else return x;\n        }));\n    }, []);\n};\n\nfunction parse (s, env, opts) {\n    var chunker = new RegExp([\n        '(' + CONTROL + ')', // control chars\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n    ].join('|'), 'g');\n    var match = s.match(chunker).filter(Boolean);\n    var commented = false;\n\n    if (!match) return [];\n    if (!env) env = {};\n    if (!opts) opts = {};\n    return match.map(function (s, j) {\n        if (commented) {\n            return;\n        }\n        if (RegExp('^' + CONTROL + '$').test(s)) {\n            return { op: s };\n        }\n\n        // Hand-written scanner/parser for Bash quoting rules:\n        //\n        //  1. inside single quotes, all characters are printed literally.\n        //  2. inside double quotes, all characters are printed literally\n        //     except variables prefixed by '$' and backslashes followed by\n        //     either a double quote or another backslash.\n        //  3. outside of any quotes, backslashes are treated as escape\n        //     characters and not printed (unless they are themselves escaped)\n        //  4. quote context can switch mid-token if there is no whitespace\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n        //     \"allonetoken\")\n        var SQ = \"'\";\n        var DQ = '\"';\n        var DS = '$';\n        var BS = opts.escape || '\\\\';\n        var quote = false;\n        var esc = false;\n        var out = '';\n        var isGlob = false;\n\n        for (var i = 0, len = s.length; i < len; i++) {\n            var c = s.charAt(i);\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n            if (esc) {\n                out += c;\n                esc = false;\n            }\n            else if (quote) {\n                if (c === quote) {\n                    quote = false;\n                }\n                else if (quote == SQ) {\n                    out += c;\n                }\n                else { // Double quote\n                    if (c === BS) {\n                        i += 1;\n                        c = s.charAt(i);\n                        if (c === DQ || c === BS || c === DS) {\n                            out += c;\n                        } else {\n                            out += BS + c;\n                        }\n                    }\n                    else if (c === DS) {\n                        out += parseEnvVar();\n                    }\n                    else {\n                        out += c;\n                    }\n                }\n            }\n            else if (c === DQ || c === SQ) {\n                quote = c;\n            }\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\n                return { op: s };\n            }\n            else if (RegExp('^#$').test(c)) {\n                commented = true;\n                if (out.length){\n                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n                }\n                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n            }\n            else if (c === BS) {\n                esc = true;\n            }\n            else if (c === DS) {\n                out += parseEnvVar();\n            }\n            else out += c;\n        }\n\n        if (isGlob) return {op: 'glob', pattern: out};\n\n        return out;\n\n        function parseEnvVar() {\n            i += 1;\n            var varend, varname;\n            //debugger\n            if (s.charAt(i) === '{') {\n                i += 1;\n                if (s.charAt(i) === '}') {\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n                }\n                varend = s.indexOf('}', i);\n                if (varend < 0) {\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\n                }\n                varname = s.substr(i, varend - i);\n                i = varend;\n            }\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n                varname = s.charAt(i);\n                i += 1;\n            }\n            else {\n                varend = s.substr(i).match(/[^\\w\\d_]/);\n                if (!varend) {\n                    varname = s.substr(i);\n                    i = s.length;\n                } else {\n                    varname = s.substr(i, varend.index);\n                    i += varend.index - 1;\n                }\n            }\n            return getVar(null, '', varname);\n        }\n    })\n    // finalize parsed aruments\n    .reduce(function(prev, arg){\n        if (arg === undefined){\n            return prev;\n        }\n        return prev.concat(arg);\n    },[]);\n\n    function getVar (_, pre, key) {\n        var r = typeof env === 'function' ? env(key) : env[key];\n        if (r === undefined && key != '')\n            r = '';\n        else if (r === undefined)\n            r = '$';\n\n        if (typeof r === 'object') {\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\n        }\n        else return pre + r;\n    }\n}\n","/**\r\n * The history controller provides an ring-buffer\r\n */\r\nexport class HistoryController {\r\n  constructor(size) {\r\n    this.size = size;\r\n    this.entries = [];\r\n    this.cursor = 0;\r\n  }\r\n\r\n  /**\r\n   * Push an entry and maintain ring buffer size\r\n   */\r\n  push(entry) {\r\n    // Skip empty entries\r\n    if (entry.trim() === \"\") return;\r\n    // Skip duplicate entries\r\n    const lastEntry = this.entries[this.entries.length - 1];\r\n    if (entry == lastEntry) return;\r\n    // Keep track of entries\r\n    this.entries.push(entry);\r\n    if (this.entries.length > this.size) {\r\n      this.entries.pop(0);\r\n    }\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Rewind history cursor on the last entry\r\n   */\r\n  rewind() {\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Returns the previous entry\r\n   */\r\n  getPrevious() {\r\n    const idx = Math.max(0, this.cursor - 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n\r\n  /**\r\n   * Returns the next entry\r\n   */\r\n  getNext() {\r\n    const idx = Math.min(this.entries.length, this.cursor + 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n}\r\n","import { parse } from \"shell-quote\";\r\n\r\n/**\r\n * Detects all the word boundaries on the given input\r\n */\r\nexport function wordBoundaries(input, leftSide = true) {\r\n  let match;\r\n  const words = [];\r\n  const rx = /\\w+/g;\r\n\r\n  while ((match = rx.exec(input))) {\r\n    if (leftSide) {\r\n      words.push(match.index);\r\n    } else {\r\n      words.push(match.index + match[0].length);\r\n    }\r\n  }\r\n\r\n  return words;\r\n}\r\n\r\n/**\r\n * The closest left (or right) word boundary of the given input at the\r\n * given offset.\r\n */\r\nexport function closestLeftBoundary(input, offset) {\r\n  const found = wordBoundaries(input, true)\r\n    .reverse()\r\n    .find(x => x < offset);\r\n  return found == null ? 0 : found;\r\n}\r\nexport function closestRightBoundary(input, offset) {\r\n  const found = wordBoundaries(input, false).find(x => x > offset);\r\n  return found == null ? input.length : found;\r\n}\r\n\r\n/**\r\n * Convert offset at the given input to col/row location\r\n *\r\n * This function is not optimized and practically emulates via brute-force\r\n * the navigation on the terminal, wrapping when they reach the column width.\r\n */\r\nexport function offsetToColRow(input, offset, maxCols) {\r\n  let row = 0,\r\n    col = 0;\r\n\r\n  for (let i = 0; i < offset; ++i) {\r\n    const chr = input.charAt(i);\r\n    if (chr == \"\\n\") {\r\n      col = 0;\r\n      row += 1;\r\n    } else {\r\n      col += 1;\r\n      if (col > maxCols) {\r\n        col = 0;\r\n        row += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { row, col };\r\n}\r\n\r\n/**\r\n * Counts the lines in the given input\r\n */\r\nexport function countLines(input, maxCols) {\r\n  return offsetToColRow(input, input.length, maxCols).row + 1;\r\n}\r\n\r\n/**\r\n * Checks if there is an incomplete input\r\n *\r\n * An incomplete input is considered:\r\n * - An input that contains unterminated single quotes\r\n * - An input that contains unterminated double quotes\r\n * - An input that ends with \"\\\"\r\n * - An input that has an incomplete boolean shell expression (&& and ||)\r\n * - An incomplete pipe expression (|)\r\n */\r\nexport function isIncompleteInput(input) {\r\n  // Empty input is not incomplete\r\n  if (input.trim() == \"\") {\r\n    return false;\r\n  }\r\n\r\n  // Check for dangling single-quote strings\r\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling double-quote strings\r\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling boolean or pipe operations\r\n  if (\r\n    input\r\n      .split(/(\\|\\||\\||&&)/g)\r\n      .pop()\r\n      .trim() == \"\"\r\n  ) {\r\n    return true;\r\n  }\r\n  // Check for tailing slash\r\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns true if the expression ends on a tailing whitespace\r\n */\r\nexport function hasTailingWhitespace(input) {\r\n  return input.match(/[^\\\\][ \\t]$/m) != null;\r\n}\r\n\r\n/**\r\n * Returns the last expression in the given input\r\n */\r\nexport function getLastToken(input) {\r\n  // Empty expressions\r\n  if (input.trim() === \"\") return \"\";\r\n  if (hasTailingWhitespace(input)) return \"\";\r\n\r\n  // Last token\r\n  const tokens = parse(input);\r\n  return tokens.pop() || \"\";\r\n}\r\n\r\n/**\r\n * Returns the auto-complete candidates for the given input\r\n */\r\nexport function collectAutocompleteCandidates(callbacks, input) {\r\n  const tokens = parse(input);\r\n  let index = tokens.length - 1;\r\n  let expr = tokens[index] || \"\";\r\n\r\n  // Empty expressions\r\n  if (input.trim() === \"\") {\r\n    index = 0;\r\n    expr = \"\";\r\n  } else if (hasTailingWhitespace(input)) {\r\n    // Expressions with danging space\r\n    index += 1;\r\n    expr = \"\";\r\n  }\r\n\r\n  // Collect all auto-complete candidates from the callbacks\r\n  const all = callbacks.reduce((candidates, { fn, args }) => {\r\n    try {\r\n      return candidates.concat(fn(index, tokens, ...args));\r\n    } catch (e) {\r\n      console.error(\"Auto-complete error:\", e);\r\n      return candidates;\r\n    }\r\n  }, []);\r\n\r\n  // Filter only the ones starting with the expression\r\n  return all.filter(txt => txt.startsWith(expr));\r\n}\r\n\r\n\r\nexport function getSharedFragment(fragment, candidates) {\r\n\r\n  // end loop when fragment length = first candidate length\r\n  if (fragment.length >= candidates[0].length) return fragment;\r\n  \r\n  // save old fragemnt\r\n  const oldFragment = fragment;\r\n  \r\n  // get new fragment\r\n  fragment += candidates[0].slice(fragment.length, fragment.length+1);\r\n\r\n  for (let i=0; i<candidates.length; i++ ) {\r\n\r\n    // return null when there's a wrong candidate\r\n    if (!candidates[i].startsWith(oldFragment)) return null;\r\n\r\n    if (!candidates[i].startsWith(fragment)) {\r\n      return oldFragment;\r\n    }\r\n  }\r\n\r\n  return getSharedFragment(fragment, candidates);\r\n}\r\n","import { HistoryController } from \"./HistoryController\";\r\nimport {\r\n  closestLeftBoundary,\r\n  closestRightBoundary,\r\n  collectAutocompleteCandidates,\r\n  countLines,\r\n  getLastToken,\r\n  hasTailingWhitespace,\r\n  isIncompleteInput,\r\n  offsetToColRow,\r\n  getSharedFragment\r\n} from \"./Utils\";\r\n\r\n/**\r\n * A local terminal controller is responsible for displaying messages\r\n * and handling local echo for the terminal.\r\n *\r\n * Local echo supports most of bash-like input primitives. Namely:\r\n * - Arrow navigation on the input\r\n * - Alt-arrow for word-boundary navigation\r\n * - Alt-backspace for word-boundary deletion\r\n * - Multi-line input for incomplete commands\r\n * - Auto-complete hooks\r\n */\r\nexport default class LocalEchoController {\r\n  constructor(term = null, options = {}) {\r\n    this.term = term;\r\n    this._handleTermData = this.handleTermData.bind(this);\r\n    this._handleTermResize = this.handleTermResize.bind(this)\r\n    \r\n    this.history = new HistoryController(options.historySize || 10);\r\n    this.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;\r\n\r\n    this._autocompleteHandlers = [];\r\n    this._active = false;\r\n    this._input = \"\";\r\n    this._cursor = 0;\r\n    this._activePrompt = null;\r\n    this._activeCharPrompt = null;\r\n    this._termSize = {\r\n      cols: 0,\r\n      rows: 0,\r\n    };\r\n\r\n    this._disposables = [];\r\n    \r\n    if (term) {\r\n      if (term.loadAddon) term.loadAddon(this);\r\n      else this.attach();\r\n    }\r\n  }\r\n\r\n  // xterm.js new plugin API:\r\n  activate(term) {\r\n    this.term = term;\r\n    this.attach();\r\n  }\r\n  dispose() {\r\n    this.detach();\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // User-Facing API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  \r\n  /**\r\n   *  Detach the controller from the terminal\r\n   */\r\n  detach() {\r\n    if (this.term.off) {\r\n      this.term.off(\"data\", this._handleTermData);\r\n      this.term.off(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.forEach(d => d.dispose());\r\n      this._disposables = [];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Attach controller to the terminal, handling events\r\n   */\r\n  attach() {\r\n    if (this.term.on) {\r\n      this.term.on(\"data\", this._handleTermData);\r\n      this.term.on(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.push(this.term.onData(this._handleTermData));\r\n      this._disposables.push(this.term.onResize(this._handleTermResize));\r\n    }\r\n    this._termSize = {\r\n      cols: this.term.cols,\r\n      rows: this.term.rows,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Register a handler that will be called to satisfy auto-completion\r\n   */\r\n  addAutocompleteHandler(fn, ...args) {\r\n    this._autocompleteHandlers.push({\r\n      fn,\r\n      args\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove a previously registered auto-complete handler\r\n   */\r\n  removeAutocompleteHandler(fn) {\r\n    const idx = this._autocompleteHandlers.findIndex(e => e.fn === fn);\r\n    if (idx === -1) return;\r\n\r\n    this._autocompleteHandlers.splice(idx, 1);\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will resolve when the user has completed\r\n   * typing a single line\r\n   */\r\n  read(prompt, continuationPrompt = \"> \") {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activePrompt = {\r\n        prompt,\r\n        continuationPrompt,\r\n        resolve,\r\n        reject\r\n      };\r\n\r\n      this._input = \"\";\r\n      this._cursor = 0;\r\n      this._active = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will be resolved when the user types a single\r\n   * character.\r\n   *\r\n   * This can be active in addition to `.read()` and will be resolved in\r\n   * priority before it.\r\n   */\r\n  readChar(prompt) {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activeCharPrompt = {\r\n        prompt,\r\n        resolve,\r\n        reject\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Abort a pending read operation\r\n   */\r\n  abortRead(reason = \"aborted\") {\r\n    if (this._activePrompt != null || this._activeCharPrompt != null) {\r\n      this.term.write(\"\\r\\n\");\r\n    }\r\n    if (this._activePrompt != null) {\r\n      this._activePrompt.reject(reason);\r\n      this._activePrompt = null;\r\n    }\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.reject(reason);\r\n      this._activeCharPrompt = null;\r\n    }\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Prints a message and changes line\r\n   */\r\n  println(message) {\r\n    this.print(message + \"\\n\");\r\n  }\r\n\r\n  /**\r\n   * Prints a message and properly handles new-lines\r\n   */\r\n  print(message) {\r\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\r\n    this.term.write(normInput.replace(/\\n/g, \"\\r\\n\"));\r\n  }\r\n\r\n  /**\r\n   * Prints a list of items using a wide-format\r\n   */\r\n  printWide(items, padding = 2) {\r\n    if (items.length == 0) return println(\"\");\r\n\r\n    // Compute item sizes and matrix row/cols\r\n    const itemWidth =\r\n      items.reduce((width, item) => Math.max(width, item.length), 0) + padding;\r\n    const wideCols = Math.floor(this._termSize.cols / itemWidth);\r\n    const wideRows = Math.ceil(items.length / wideCols);\r\n\r\n    // Print matrix\r\n    let i = 0;\r\n    for (let row = 0; row < wideRows; ++row) {\r\n      let rowStr = \"\";\r\n\r\n      // Prepare columns\r\n      for (let col = 0; col < wideCols; ++col) {\r\n        if (i < items.length) {\r\n          let item = items[i++];\r\n          item += \" \".repeat(itemWidth - item.length);\r\n          rowStr += item;\r\n        }\r\n      }\r\n      this.println(rowStr);\r\n    }\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // Internal API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n   * Apply prompts to the given input\r\n   */\r\n  applyPrompts(input) {\r\n    const prompt = (this._activePrompt || {}).prompt || \"\";\r\n    const continuationPrompt =\r\n      (this._activePrompt || {}).continuationPrompt || \"\";\r\n\r\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\r\n  }\r\n\r\n  /**\r\n   * Advances the `offset` as required in order to accompany the prompt\r\n   * additions to the input.\r\n   */\r\n  applyPromptOffset(input, offset) {\r\n    const newInput = this.applyPrompts(input.substr(0, offset));\r\n    return newInput.length;\r\n  }\r\n\r\n  /**\r\n   * Clears the current prompt\r\n   *\r\n   * This function will erase all the lines that display the current prompt\r\n   * and move the cursor in the beginning of the first line of the prompt.\r\n   */\r\n  clearInput() {\r\n    const currentPrompt = this.applyPrompts(this._input);\r\n\r\n    // Get the overall number of lines to clear\r\n    const allRows = countLines(currentPrompt, this._termSize.cols);\r\n\r\n    // Get the line we are currently in\r\n    const promptCursor = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col, row } = offsetToColRow(\r\n      currentPrompt,\r\n      promptCursor,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // First move on the last line\r\n    const moveRows = allRows - row - 1;\r\n    for (var i = 0; i < moveRows; ++i) this.term.write(\"\\x1B[E\");\r\n\r\n    // Clear current input line(s)\r\n    this.term.write(\"\\r\\x1B[K\");\r\n    for (var i = 1; i < allRows; ++i) this.term.write(\"\\x1B[F\\x1B[K\");\r\n  }\r\n\r\n  /**\r\n   * Replace input with the new input given\r\n   *\r\n   * This function clears all the lines that the current input occupies and\r\n   * then replaces them with the new input.\r\n   */\r\n  setInput(newInput, clearInput = true) {\r\n    // Clear current input\r\n    if (clearInput) this.clearInput();\r\n\r\n    // Write the new input lines, including the current prompt\r\n    const newPrompt = this.applyPrompts(newInput);\r\n    this.print(newPrompt);\r\n\r\n    // Trim cursor overflow\r\n    if (this._cursor > newInput.length) {\r\n      this._cursor = newInput.length;\r\n    }\r\n\r\n    // Move the cursor to the appropriate row/col\r\n    const newCursor = this.applyPromptOffset(newInput, this._cursor);\r\n    const newLines = countLines(newPrompt, this._termSize.cols);\r\n    const { col, row } = offsetToColRow(\r\n      newPrompt,\r\n      newCursor,\r\n      this._termSize.cols\r\n    );\r\n    const moveUpRows = newLines - row - 1;\r\n\r\n    this.term.write(\"\\r\");\r\n    for (var i = 0; i < moveUpRows; ++i) this.term.write(\"\\x1B[F\");\r\n    for (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\r\n\r\n    // Replace input\r\n    this._input = newInput;\r\n  }\r\n\r\n  /**\r\n   * This function completes the current input, calls the given callback\r\n   * and then re-displays the prompt.\r\n   */\r\n  printAndRestartPrompt(callback) {\r\n    const cursor = this._cursor;\r\n\r\n    // Complete input\r\n    this.setCursor(this._input.length);\r\n    this.term.write(\"\\r\\n\");\r\n\r\n    // Prepare a function that will resume prompt\r\n    const resume = () => {\r\n      this._cursor = cursor;\r\n      this.setInput(this._input);\r\n    };\r\n\r\n    // Call the given callback to echo something, and if there is a promise\r\n    // returned, wait for the resolution before resuming prompt.\r\n    const ret = callback();\r\n    if (ret == null) {\r\n      resume();\r\n    } else {\r\n      ret.then(resume);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the new cursor position, as an offset on the input string\r\n   *\r\n   * This function:\r\n   * - Calculates the previous and current\r\n   */\r\n  setCursor(newCursor) {\r\n    if (newCursor < 0) newCursor = 0;\r\n    if (newCursor > this._input.length) newCursor = this._input.length;\r\n\r\n    // Apply prompt formatting to get the visual status of the display\r\n    const inputWithPrompt = this.applyPrompts(this._input);\r\n    const inputLines = countLines(inputWithPrompt, this._termSize.cols);\r\n\r\n    // Estimate previous cursor position\r\n    const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col: prevCol, row: prevRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      prevPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Estimate next cursor position\r\n    const newPromptOffset = this.applyPromptOffset(this._input, newCursor);\r\n    const { col: newCol, row: newRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      newPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Adjust vertically\r\n    if (newRow > prevRow) {\r\n      for (let i = prevRow; i < newRow; ++i) this.term.write(\"\\x1B[B\");\r\n    } else {\r\n      for (let i = newRow; i < prevRow; ++i) this.term.write(\"\\x1B[A\");\r\n    }\r\n\r\n    // Adjust horizontally\r\n    if (newCol > prevCol) {\r\n      for (let i = prevCol; i < newCol; ++i) this.term.write(\"\\x1B[C\");\r\n    } else {\r\n      for (let i = newCol; i < prevCol; ++i) this.term.write(\"\\x1B[D\");\r\n    }\r\n\r\n    // Set new offset\r\n    this._cursor = newCursor;\r\n  }\r\n\r\n  /**\r\n   * Move cursor at given direction\r\n   */\r\n  handleCursorMove(dir) {\r\n    if (dir > 0) {\r\n      const num = Math.min(dir, this._input.length - this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    } else if (dir < 0) {\r\n      const num = Math.max(dir, -this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Erase a character at cursor location\r\n   */\r\n  handleCursorErase(backspace) {\r\n    const { _cursor, _input } = this;\r\n    if (backspace) {\r\n      if (_cursor <= 0) return;\r\n      const newInput = _input.substr(0, _cursor - 1) + _input.substr(_cursor);\r\n      this.clearInput();\r\n      this._cursor -= 1;\r\n      this.setInput(newInput, false);\r\n    } else {\r\n      const newInput = _input.substr(0, _cursor) + _input.substr(_cursor + 1);\r\n      this.setInput(newInput);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Insert character at cursor location\r\n   */\r\n  handleCursorInsert(data) {\r\n    const { _cursor, _input } = this;\r\n    const newInput = _input.substr(0, _cursor) + data + _input.substr(_cursor);\r\n    this._cursor += data.length;\r\n    this.setInput(newInput);\r\n  }\r\n\r\n  /**\r\n   * Handle input completion\r\n   */\r\n  handleReadComplete() {\r\n    if (this.history) {\r\n      this.history.push(this._input);\r\n    }\r\n    if (this._activePrompt) {\r\n      this._activePrompt.resolve(this._input);\r\n      this._activePrompt = null;\r\n    }\r\n    this.term.write(\"\\r\\n\");\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Handle terminal resize\r\n   *\r\n   * This function clears the prompt using the previous configuration,\r\n   * updates the cached terminal size information and then re-renders the\r\n   * input. This leads (most of the times) into a better formatted input.\r\n   */\r\n  handleTermResize(data) {\r\n    const { rows, cols } = data;\r\n    this.clearInput();\r\n    this._termSize = { cols, rows };\r\n    this.setInput(this._input, false);\r\n  }\r\n\r\n  /**\r\n   * Handle terminal input\r\n   */\r\n  handleTermData(data) {\r\n    if (!this._active) return;\r\n\r\n    // If we have an active character prompt, satisfy it in priority\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.resolve(data);\r\n      this._activeCharPrompt = null;\r\n      this.term.write(\"\\r\\n\");\r\n      return;\r\n    }\r\n\r\n    // If this looks like a pasted input, expand it\r\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\r\n      const normData = data.replace(/[\\r\\n]+/g, \"\\r\");\r\n      Array.from(normData).forEach(c => this.handleData(c));\r\n    } else {\r\n      this.handleData(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a single piece of information from the terminal.\r\n   */\r\n  handleData(data) {\r\n    if (!this._active) return;\r\n    const ord = data.charCodeAt(0);\r\n    let ofs;\r\n\r\n    // Handle ANSI escape sequences\r\n    if (ord == 0x1b) {\r\n      switch (data.substr(1)) {\r\n        case \"[A\": // Up arrow\r\n          if (this.history) {\r\n            let value = this.history.getPrevious();\r\n            if (value) {\r\n              this.setInput(value);\r\n              this.setCursor(value.length);\r\n            }\r\n          }\r\n          break;\r\n\r\n        case \"[B\": // Down arrow\r\n          if (this.history) {\r\n            let value = this.history.getNext();\r\n            if (!value) value = \"\";\r\n            this.setInput(value);\r\n            this.setCursor(value.length);\r\n          }\r\n          break;\r\n\r\n        case \"[D\": // Left Arrow\r\n          this.handleCursorMove(-1);\r\n          break;\r\n\r\n        case \"[C\": // Right Arrow\r\n          this.handleCursorMove(1);\r\n          break;\r\n\r\n        case \"[3~\": // Delete\r\n          this.handleCursorErase(false);\r\n          break;\r\n\r\n        case \"[F\": // End\r\n          this.setCursor(this._input.length);\r\n          break;\r\n\r\n        case \"[H\": // Home\r\n          this.setCursor(0);\r\n          break;\r\n\r\n        case \"b\": // ALT + LEFT\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"f\": // ALT + RIGHT\r\n          ofs = closestRightBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"\\x7F\": // CTRL + BACKSPACE\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) {\r\n            this.setInput(\r\n              this._input.substr(0, ofs) + this._input.substr(this._cursor)\r\n            );\r\n            this.setCursor(ofs);\r\n          }\r\n          break;\r\n      }\r\n\r\n      // Handle special characters\r\n    } else if (ord < 32 || ord === 0x7f) {\r\n      switch (data) {\r\n        case \"\\r\": // ENTER\r\n          if (isIncompleteInput(this._input)) {\r\n            this.handleCursorInsert(\"\\n\");\r\n          } else {\r\n            this.handleReadComplete();\r\n          }\r\n          break;\r\n\r\n        case \"\\x7F\": // BACKSPACE\r\n          this.handleCursorErase(true);\r\n          break;\r\n\r\n        case \"\\t\": // TAB\r\n          if (this._autocompleteHandlers.length > 0) {\r\n            const inputFragment = this._input.substr(0, this._cursor);\r\n            const hasTailingSpace = hasTailingWhitespace(inputFragment);\r\n            const candidates = collectAutocompleteCandidates(\r\n              this._autocompleteHandlers,\r\n              inputFragment\r\n            );\r\n\r\n            // Sort candidates\r\n            candidates.sort();\r\n\r\n            // Depending on the number of candidates, we are handing them in\r\n            // a different way.\r\n            if (candidates.length === 0) {\r\n              // No candidates? Just add a space if there is none already\r\n              if (!hasTailingSpace) {\r\n                //this.handleCursorInsert(\" \");\r\n              }\r\n            } else if (candidates.length === 1) {\r\n              // Just a single candidate? Complete\r\n              const lastToken = getLastToken(inputFragment);\r\n              this.handleCursorInsert(\r\n                candidates[0].substr(lastToken.length)// + \" \"\r\n              );\r\n            } else if (candidates.length <= this.maxAutocompleteEntries) {\r\n\r\n              // search for a shared fragement\r\n              const sameFragment = getSharedFragment(inputFragment, candidates);\r\n              \r\n              // if there's a shared fragement between the candidates\r\n              // print complete the shared fragment\r\n              if (sameFragment) {\r\n                const lastToken = getLastToken(inputFragment);\r\n                this.handleCursorInsert(\r\n                  sameFragment.substr(lastToken.length)\r\n                );\r\n              }\r\n\r\n              // If we are less than maximum auto-complete candidates, print\r\n              // them to the user and re-start prompt\r\n              this.printAndRestartPrompt(() => {\r\n                this.printWide(candidates);\r\n              });\r\n            } else {\r\n              // If we have more than maximum auto-complete candidates, print\r\n              // them only if the user acknowledges a warning\r\n              this.printAndRestartPrompt(() =>\r\n                this.readChar(\r\n                  `Display all ${candidates.length} possibilities? (y or n)`\r\n                ).then(yn => {\r\n                  if (yn == \"y\" || yn == \"Y\") {\r\n                    this.printWide(candidates);\r\n                  }\r\n                })\r\n              );\r\n            }\r\n          } else {\r\n            this.handleCursorInsert(\"    \");\r\n          }\r\n          break;\r\n\r\n        case \"\\x03\": // CTRL+C\r\n          this.setCursor(this._input.length);\r\n          this.term.write(\"^C\\r\\n\" + ((this._activePrompt || {}).prompt || \"\"));\r\n          this._input = \"\";\r\n          this._cursor = 0;\r\n          if (this.history) this.history.rewind();\r\n          break;\r\n      }\r\n\r\n      // Handle visible characters\r\n    } else {\r\n      this.handleCursorInsert(data);\r\n    }\r\n  }\r\n}\r\n","import LocalEchoController from \"./lib/LocalEchoController\";\r\nexport { HistoryController } from './lib/HistoryController';\r\n\r\nexport default LocalEchoController;\r\n"],"sourceRoot":""}